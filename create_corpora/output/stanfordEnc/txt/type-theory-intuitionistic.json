[{"date.published":"2016-02-12","date.changed":"2020-06-08","url":"https://plato.stanford.edu/entries/type-theory-intuitionistic/","author1":"Peter Dybjer","author1.info":"http://www.cse.chalmers.se/~peterd/","author2.info":"http://staff.math.su.se/palmgren/","entry":"type-theory-intuitionistic","body.text":"\n\nIntuitionistic type theory (also constructive type theory or\nMartin-Löf type theory) is a formal logical system and philosophical\nfoundation for\n constructive mathematics. It is a\nfull-scale system which aims to play a similar role for constructive\nmathematics as\n Zermelo-Fraenkel Set Theory\n does for\nclassical mathematics. It is based on the propositions-as-types\nprinciple and clarifies the Brouwer-Heyting-Kolmogorov interpretation\nof intuitionistic logic. It extends this interpretation to the more\ngeneral setting of intuitionistic type theory and thus provides a\ngeneral conception not only of what a constructive proof is, but also\nof what a constructive mathematical object is. The main idea is that\nmathematical concepts such as elements, sets and functions are\nexplained in terms of concepts from programming such as data\nstructures, data types and programs. This article describes the formal\nsystem of intuitionistic type theory and its semantic foundations.\n\nIn this entry, we first give an overview of the most important\naspects of intuitionistic type theory—a kind of “extended\nabstract”. It is meant for a reader who is already somewhat\nfamiliar with the theory. Section 2 on the other hand, is meant for a\nreader who is new to intuitionistic type theory but familiar with\ntraditional logic, including propositional and predicate logic,\narithmetic, and set theory. Here we informally introduce several\naspects which distinguishes intuitionistic type theory from these\ntraditional theories. In Section 3 we present a basic version of the\ntheory, close to Martin-Löf’s first published version from\n1972. The reader who was intrigued by the informality of Section 2\nwill now see in detail how the theory is built up. Section 4 then\npresents a number of important extensions of the basic theory. In\nparticular, it emphasizes the central role of inductive (and\ninductive-recursive) definitions. Section 5 introduces the underlying\nphilosophical ideas including the theory of meaning developed by\nMartin-Löf. While Section 5 is about philosophy and foundations,\nSection 6 gives an overview of mathematical models of the theory. In\nSection 7 finally, we describe several important variations of the\ncore Martin-Löf “intensional” theory described in\nSection 3 and 4.\n\nWe begin with a bird’s eye view of some important aspects of\nintuitionistic type theory. Readers who are unfamiliar with the theory\nmay prefer to skip it on a first reading. The origins of intuitionistic type theory are Brouwer’s\nintuitionism and Russell’s type theory. Like\n Church’s classical simple theory of types\n it is based on the lambda calculus with types,\nbut differs from it in that it is based on the propositions-as-types\nprinciple, discovered by Curry (1958) for propositional logic and\nextended to predicate logic by Howard (1980) and de Bruijn\n(1970). This extension was made possible by the introduction of\nindexed families of types (dependent types) for representing the\npredicates of predicate logic. In this way all logical connectives and\nquantifiers can be interpreted by type formers. In intuitionistic type\ntheory further types are added, such as a type of natural numbers, a\ntype of small types (a universe) and a type of well-founded trees. The\nresulting theory contains intuitionistic number theory (Heyting\narithmetic) and much more. The theory is formulated in natural deduction where the rules for\neach type former are classified as formation, introduction,\nelimination, and equality rules. These rules exhibit certain\nsymmerties between the introduction and elimination rules following\nGentzen’s and Prawitz’ treatment of natural deduction, \nas explained in the entry on\n proof-theoretic semantics. The elements of propositions, when interpreted as types, are\ncalled proof-objects. When proof-objects are added to the\nnatural deduction calculus it becomes a typed lambda calculus with\ndependent types, which extends Church’s original typed lambda\ncalculus. The equality rules are computation rules for the terms of\nthis calculus. Each function definable in the theory is total and\ncomputable. Intuitionistic type theory is thus a typed functional\nprogramming language with the unusual property that all programs\nterminate. Intuitionistic type theory is not only a formal logical system but\nalso provides a comprehensive philosophical framework for\nintuitionism. It is an interpreted language, where the\ndistinction between the demonstration of a judgment and\nthe proof of a proposition plays a fundamental role (Sundholm\n2012). The framework clarifies the Brouwer-Heyting-Kolmogorov\ninterpretation of intuitionistic logic and extends it to the more\ngeneral setting of intuitionistic type theory. In doing so it provides\na general conception not only of what a constructive proof is, but\nalso of what a constructive mathematical object is. The meaning of the\njudgments of intuitionistic type theory is explained in terms of\ncomputations of the canonical forms of types and terms. These\ninformal, intuitive meaning explanations are\n“pre-mathematical” and should be contrasted to formal\nmathematical models developed inside a standard mathematical framework\nsuch as set theory. This meaning theory also justifies a variety of inductive,\nrecursive, and inductive-recursive definitions. Although\nproof-theoretically strong notions can be justified, such as analogues\nof certain large cardinals, the system is considered\npredicative. Impredicative definitions of the kind found in\nhigher-order logic, intuitionistic set theory, and topos theory are\nnot part of the theory. Neither is Markov’s principle, and thus the\ntheory is distinct from Russian constructivism. An alternative formal logical system for predicative constructive\nmathematics is Myhill and Aczel’s\n constructive Zermelo-Fraenkel set theory\n (CZF). This theory, which is based on\nintuitionistic first-order predicate logic and weakens some of the\naxioms of classical Zermelo-Fraenkel Set Theory, has a natural\ninterpretation in intuitionistic type theory. Martin-Löf’s meaning\nexplanations thus also indirectly form a basis for CZF. Variants of intuitionistic type theory underlie several widely used\nproof assistants, including NuPRL, Coq, and Agda. These proof\nassistants are computer systems that have been used for formalizing\nlarge and complex proofs of mathematical theorems, such as the Four\nColour Theorem in graph theory and the Feit-Thompson Theorem in finite\ngroup theory. They have also been used to prove the correctness of a realistic C compiler (Leroy 2009) and other \ncomputer software. Philosophically and practically, intuitionistic type theory is a\nfoundational framework where constructive mathematics and computer\nprogramming are, in a deep sense, the same. This point has been\nemphasized by (Gonthier 2008) in the paper in which he describes his\nproof of the Four Colour Theorem: The approach that proved successful for this proof was to turn\nalmost every mathematical concept into a data structure or a program\nin the Coq system, thereby converting the entire enterprise into one\nof program verification. Intuitionistic type theory offers a new way of analyzing logic,\nmainly through its introduction of explicit proof objects. This\nprovides a direct computational interpretation of logic, since there\nare computation rules for proof objects. As regards expressive power,\nintuitionistic type theory may be considered as an extension of\nfirst-order logic, much as higher order logic, but predicative. Russell developed\n type theory in response to his discovery\nof a paradox in naive set theory. In his ramified type theory\nmathematical objects are classified according to their types:\nthe type of propositions, the type of objects, the type of properties\nof objects, etc. When Church developed his\n simple theory of types on the\n basis of a typed version of his lambda calculus he added\nthe rule that there is a type of functions between any two types of\nthe theory. Intuitionistic type theory further extends the simply\ntyped lambda calculus with dependent types, that is, indexed families\nof types. An example is the family of types of \\(n\\)-tuples indexed by\n\\(n\\). Types have been widely used in programming for a long time. Early\nhigh-level programming languages introduced types of integers and\nfloating point numbers. Modern programming languages often have rich\ntype systems with many constructs for forming new\ntypes. Intuitionistic type theory is a functional programming language\nwhere the type system is so rich that practically any conceivable\nproperty of a program can be expressed as a type. Types can thus be\nused as specifications of the task of a program. Brouwer’s analysis of logic led him to an intuitionistic logic\nwhich rejects the law of excluded middle and the law of double\nnegation. These laws are not valid in intuitionistic type theory. Thus\nit does not contain classical (Peano) arithmetic but only\nintuitionistic (Heyting) arithmetic. (It is another matter that Peano\narithmetic can be interpreted in Heyting arithmetic by the double\nnegation interpretation, see the entry on\n intuitionistic logic.) Consider a theorem of intuitionistic arithmetic, such as the\ndivision theorem A formal proof (in the usual sense) of this theorem is a sequence\n(or tree) of formulas, where the last (root) formula is the theorem\nand each formula in the sequence is either an axiom (a leaf) or the\nresult of applying an inference rule to some earlier (higher)\nformulas. When the division theorem is proved in intuitionistic type theory,\nwe do not only build a formal proof in the usual sense but also\na construction (or proof-object)\n“\\(\\divi\\)” which witnesses the truth of the theorem. We\nwrite to express that \\(\\divi\\) is a proof-object for the division\ntheorem, that is, an element of the type representing the division\ntheorem. When propositions are represented as types, the\n\\(\\forall\\)-quantifier is identified with the dependent function space\nformer (or general cartesian product) \\(\\Pi\\), the\n\\(\\exists\\)-quantifier with the dependent pairs type former (or\ngeneral disjoint sum) \\(\\Sigma\\), conjunction \\(\\wedge\\) with cartesian product \\( \\times \\), the identity relation = with the\ntype former \\(\\I\\) of proof-objects of identities, and the greater\nthan relation \\(>\\) with the type former \\(\\GT\\) of\nproof-objects of greater-than statements. Using\n“type-notation” we thus write to express that the proof object “\\(\\divi\\)” is a\nfunction which maps two numbers \\(m\\) and \\(n\\) and a proof-object \\(p\\) witnessing that\n\\(m > 0\\) to a quadruple \\((q,(r,(s,t)))\\), where \\(q\\) is the quotient\nand \\(r\\) is the remainder obtained when dividing \\(n\\) by \\(m\\). The\nthird component \\(s\\) is a proof-object witnessing the fact that \\(mq\n+ r = n\\) and the fourth component \\(t\\) is a proof object witnessing \\(m > r \\). Crucially, \\(\\divi\\) is not only a function in the classical sense;\nit is also a function in the intuitionistic sense, that is, a program\nwhich computes the output \\((q,(r,(s,t)))\\) when given \\(m\\), \\(n\\), \\(p\\)\nas inputs. This program is a term in a lambda calculus with special\nconstants, that is, a program in a functional programming\nlanguage. Intuitionistic type theory can be considered as an extension of\nfirst-order logic, much as higher order logic is an extension of first\norder logic. In higher order logic we find some individual domains\nwhich can be interpreted as any sets we like. If there are relational\nconstants in the signature these can be interpreted as any relations\nbetween the sets interpreting the individual domains. On top of that\nwe can quantify over relations, and over relations of relations,\netc. We can think of higher order logic as first-order logic equipped\nwith a way of introducing new domains of quantification: if \\(S_1,\n\\ldots, S_n\\) are domains of quantification then \\((S_1,\\ldots,S_n)\\)\nis a new domain of quantification consisting of all the n-ary\nrelations between the domains \\(S_1,\\ldots,S_n\\). Higher order logic\nhas a straightforward set-theoretic interpretation where\n\\((S_1,\\ldots,S_n)\\) is interpreted as the power set \\(P(A_1 \\times\n\\cdots \\times A_n)\\) where \\(A_i\\) is the interpretation of \\(S_i\\),\nfor \\(i=1,\\ldots,n\\). This is the kind of higher order logic or simple\ntheory of types that Ramsey, Church and others introduced. Intuitionistic type theory can be viewed in a similar way, only\nhere the possibilities for introducing domains of quantification are\nricher, one can use \\(\\Sigma, \\Pi, +, \\I\\) to construct new ones from\nold. (Section 3.1; Martin-Löf 1998\n[1972]). Intuitionistic type theory has a straightforward\nset-theoretic interpretation as well, where \\(\\Sigma\\), \\(\\Pi\\) etc\nare interpreted as the corresponding set-theoretic constructions; see\nbelow. We can add to intuitionistic type theory unspecified individual\ndomains just as in HOL. These are interpreted as sets as for HOL. Now\nwe exhibit a difference from HOL: in intuitionistic type theory we can\nintroduce unspecified family symbols. We can introduce \\(T\\) as a\nfamily of types over the individual domain \\(S\\): If \\(S\\) is interpreted as \\(A\\), \\(T\\) can be interpreted as any\nfamily of sets indexed by \\(A\\). As a non-mathematical example, we can\nrender the binary relation loves between members of an\nindividual domain of people as follows. Introduce the binary\nfamily Loves over the domain People The interpretation can be any family of sets \\(B_{x,y}\\) (\\(x{:}A\\),\n\\(y{:}A\\)). How does this cover the standard notion of relation? Suppose\nwe have a binary relation \\(R\\) on \\(A\\) in the familiar set-theoretic\nsense. We can make a binary family corresponding to this as\nfollows Now clearly \\(B_{x,y}\\) is nonempty if and only if \\(R(x,y)\\)\nholds. (We could have chosen any other element from our set theoretic\nuniverse than 0 to indicate truth.) Thus from any relation we can\nconstruct a family whose truth of \\(x,y\\) is equivalent to \\(B_{x,y}\\)\nbeing non-empty. Note that this interpretation does not care what the\nproof for \\(R(x,y)\\) is, just that it holds. Recall that\nintuitionistic type theory interprets propositions as types, so \n\\(p{:} {\\rm Loves}({\\rm John}, {\\rm Mary})\\) means that \\({\\rm Loves}({\\rm\nJohn}, {\\rm Mary})\\) is true. The interpretation of relations as families allows for keeping\ntrack of proofs or evidence that \\(R(x,y)\\) holds, but we may also\nchose to ignore it. In Montague semantics,\n higher order logic is used to give\nsemantics of natural language (and examples as above). Ranta (1994)\nintroduced the idea to instead employ intuitionistic type theory to\nbetter capture sentence structure with the help of dependent\ntypes. In contrast, how would the mathematical relation \\(>\\) between\nnatural numbers be handled in intuitionistic type theory? First of all\nwe need a type of numbers \\(\\N\\). We could in principle introduce an\nunspecified individual domain \\(\\N\\), and then add axioms just as we\ndo in first-order logic when we set up the axiom system for Peano\narithmetic. However this would not give us the desirable computational\ninterpretation. So as explained below we lay down introduction rules\nfor constructing new natural numbers in \\(\\N\\) and elimination and\ncomputation rules for defining functions on \\(\\N\\) (by recursion). The\nstandard order relation \\(>\\) should satisfy The right hand is rendered as \\(\\Sigma z{:}\\N.\\, \\I(\\N,y+z+1,x)\\) in\nintuitionistic type theory, and we take this as definition of relation\n\\(>\\). (\\(+\\) is defined by recursive equations, \\(\\I\\) is the\nidentity type construction). Now all the properties of \\(>\\) are\ndetermined by the mentioned introduction and elimination and\ncomputation rules for \\(\\N\\). The type system of intuitionistic type theory is very\nexpressive. As a consequence the well-formedness of a type is no\nlonger a simple matter of parsing, it is something which needs to be\nproved. Well-formedness of a type is one form of judgment of\nintuitionistic type theory. Well-typedness of a term with respect to a\ntype is another. Furthermore, there are equality judgments for types\nand terms. This is yet another way in which intuitionistic type theory\ndiffers from ordinary first order logic with its focus on the sole\njudgment expressing the truth of a proposition. While a standard presentation of first-order logic would follow\nTarski in defining the notion of model, intuitionistic type theory\nfollows the tradition of Brouwerian meaning theory as further\ndeveloped by Heyting and Kolmogorov, the so called BHK-interpretation\nof logic. The key point is that the proof of an implication \\(A\n\\supset B \\) is a method that transforms a proof of \\(A\\) to\na proof of \\(B\\). In intuitionistic type theory this method is\nformally represented by the program \\(f {:} A \\supset B\\) or \\(f {:} A\n\\rightarrow B\\): the type of proofs of an implication \\(A \\supset B\\)\nis the type of functions which maps proofs of \\(A\\) to proofs of\n\\(B\\). Moreover, whereas Tarski semantics is usually presented\nmeta-mathematically, and assumes set theory, Martin-Löf’s meaning\ntheory of intuitionistic type theory should be understood directly and\n“pre-mathematically”, that is, without assuming a\nmeta-language such as set theory. Readers with a background in the lambda calculus and functional\nprogramming can get an alternative first approximation of\nintuitionistic type theory by thinking about it as a typed functional\nprogramming language in the style of Haskell or one of the dialects of\nML. However, it differs from these in two crucial aspects: (i) it has\ndependent types (see below) and (ii) all typable programs\nterminate. (Note that intuitionistic type theory has influenced recent\nextensions of Haskell with generalized algebraic datatypes\nwhich sometimes can play a similar role as inductively defined\ndependent types.) As already mentioned, the principle that a proposition is the type of its proofs. is fundamental to intuitionistic type theory. This principle is\nalso known as the Curry-Howard correspondence or even Curry-Howard\nisomorphism. Curry discovered a correspondence between the\nimplicational fragment of intuitionistic logic and the simply typed\nlambda-calculus. Howard extended this correspondence to first-order\npredicate logic. In intuitionistic type theory this correspondence\nbecomes an identification of proposition and types, which has\nbeen extended to include quantification over higher types and\nmore. So what are these proof-objects like? They should not be thought of\nas logical derivations, but rather as some (structured) symbolic\nevidence that something is true. Another term for such evidence is\n“truth-maker”. It is instructive, as a somewhat crude first approximation, to\nreplace types by ordinary sets in this correspondence. Define a set\n\\(\\E_{m,n}\\), depending on \\(m, n \\in {{\\mathbb N}}\\), by: Then \\(\\E_{m,n}\\) is nonempty exactly when \\(m=n\\). The set\n\\(\\E_{m,n}\\) corresponds to the proposition \\(m=n\\), and the number\n\\(0\\) is a proof-object (truth-maker) inhabiting the sets\n\\(\\E_{m,m}\\). Consider the proposition that \\(m\\) is an even number\nexpressed as the formula \\(\\exists n \\in {{\\mathbb N}}. m= 2n\\). We\ncan build a set of proof-objects corresponding to this formula by\nusing the general set-theoretic sum operation. Suppose that \\(A_n\\)\n(\\(n\\in {{\\mathbb N}}\\)) is a family of sets. Then its disjoint sum is\ngiven by the set of pairs If we apply this construction to the family \\(A_n = \\E_{m,2n}\\) we\nsee that \\((\\Sigma n \\in {{\\mathbb N}})\\E_{m,2n}\\) is nonempty exactly\nwhen there is an \\(n\\in {{\\mathbb N}}\\) with \\(m=2n\\). Using the\ngeneral set-theoretic product operation \\((\\Pi n \\in {{\\mathbb\nN}})A_n\\) we can similarly obtain a set corresponding to a universally\nquantified proposition. In intuitionistic type theory there are primitive type formers\n\\(\\Sigma\\) and \\(\\Pi\\) for general sums and products, and \\(\\I\\) for\nidentity types, analogous to the set-theoretic constructions described\nabove. The identity type \\(\\I(\\N,m,n)\\) corresponding to the\nset \\(\\E_{m,n}\\) is an example of a dependent type since it\ndepends on \\(m\\) and \\(n\\). It is also called an indexed family of\ntypes since it is a family of types indexed by \\(m\\) and\n\\(n\\). Similarly, we can form the general disjoint sum \\(\\Sigma x {:}\nA.\\, B\\) and the general cartesian product \\(\\Pi x {:} A.\\, B\\) of such a\nfamily of types \\(B\\) indexed by \\(x {:} A\\), corresponding to the set\ntheoretic sum and product operations above. Dependent types can also be defined by primitive recursion. An\nexample is the type of \\(n\\)-tuples \\(A^n\\) of elements of type \\(A\\)\nand indexed by \\(n {:} N\\) defined by the equations  where \\(1\\) is a\none element type and \\(\\times\\) denotes the cartesian product of two\ntypes. We note that dependent types introduce computation in types:\nthe defining rules above are computation rules. For example, the\nresult of computing \\(A^3\\) is \\(A \\times (A \\times (A \\times\n1))\\). With propositions as types, predicates become dependent types. For\nexample, the predicate \\(\\mathrm{Prime}(x)\\) becomes the type of\nproofs that \\(x\\) is prime. This type depends on\n\\(x\\). Similarly, \\(x < y\\) is the type of proofs that \\(x\\) is\nless than \\(y\\). According to the Curry-Howard interpretation of propositions as\ntypes, the logical constants are interpreted as type formers: \nwhere \\(\\Sigma x {:} A.\\, B\\) is the\ndisjoint sum of the \\(A\\)-indexed family of types \\(B\\) and \\(\\Pi x {:}\nA.\\, B\\) is its cartesian product. The canonical elements of \\(\\Sigma x {:}\nA.\\, B\\) are pairs \\((a,b)\\) such that \\(a {:} A\\) and \\(b {:} B[x:=a]\\)\n(the type obtained by substituting all free occurrences of \\(x\\) in\n\\(B\\) by \\(a\\)). The elements of \\(\\Pi x {:} A.\\, B\\) are (computable)\nfunctions \\(f\\) such that \\(f\\,a {:} B[x:=a]\\), whenever \\(a {:} A\\). For example, consider the proposition \n\nexpressing that there are\narbitrarily large primes. Under the Curry-Howard interpretation this\nbecomes the type \\(\\Pi m {:} \\N.\\, \\Sigma n {:} \\N.\\, m \\lt n \\times\n\\mathrm{Prime}(n)\\) of functions which map a number \\(m\\) to a triple\n\\((n,(p,q))\\), where \\(n\\) is a number, \\(p\\) is a proof that \\(m \\lt\nn\\) and \\(q\\) is a proof that \\(n\\) is prime. This is the proofs\nas programs principle: a constructive proof that there are\narbitrarily large primes becomes a program which given any number\nproduces a larger prime together with proofs that it indeed is larger\nand indeed is prime. Note that the proof which derives a contradiction from the\nassumption that there is a largest prime is not constructive, since it\ndoes not explicitly give a way to compute an even larger prime. To\nturn this proof into a constructive one we have to show explicitly how\nto construct the larger prime. (Since proposition (\\ref{prop1}) above\nis a \\(\\Pi^0_2\\)-formula we can for example use Friedman’s\nA-translation to turn such a proof in classical arithmetic into a\nproof in intuitionistic arithmetic and thus into a proof in\nintuitionistic type theory.) We now present a core version of intuitionistic type theory,\nclosely related to the first version of the theory presented by\nMartin-Löf in 1972 (Martin-Löf 1998 [1972]). In addition to\nthe type formers needed for the Curry-Howard interpretation of typed\nintuitionistic predicate logic listed above, we have two types: the\ntype \\(\\N\\) of natural numbers and the type \\(\\U\\) of small types. The resulting theory can be shown to contain intuitionistic number\ntheory \\(\\HA\\) (Heyting arithmetic), Gödel’s System \\(\\T\\) of\nprimitive recursive functions of higher type, and the theory\n\\(\\HA^\\omega\\) of Heyting arithmetic of higher type. This core intuitionistic type theory is not only the original one,\nbut perhaps the minimal version which exhibits the essential features\nof the theory. Later extensions with primitive identity types,\nwell-founded tree types, universe hierarchies, and general notions of\ninductive and inductive-recursive definitions have increased the\nproof-theoretic strength of the theory and also made it more\nconvenient for programming and formalization of mathematics. For\nexample, with the addition of well-founded trees we can interpret the\nConstructive Zermelo-Fraenkel Set Theory \\(\\CZF\\) of Aczel\n(1978 [1977]). However, we will\nwait until the next section to describe those extensions. In Martin-Löf (1996) a general philosophy of logic is presented\nwhere the traditional notion of judgment is expanded and given a\ncentral position. A judgment is no longer just an affirmation or\ndenial of a proposition, but a general act of knowledge. When\nreasoning mathematically we make judgments about mathematical\nobjects. One form of judgment is to state that some mathematical\nstatement is true. Another form of judgment is to state that something\nis a mathematical object, for example a set. The logical rules give\nmethods for producing correct judgments from earlier judgments. The\njudgments obtained by such rules can be presented in tree form or in sequential form The latter form is common in mathematical arguments. Such a\nsequence or tree formed by logical rules from axioms is\na derivation or demonstration of a judgment. First-order reasoning may be presented using a single kind of\njudgment: the proposition \\(B\\) is true under the hypothesis that the\npropositions \\(A_1, \\ldots, A_n\\) are all true. We write this hypothetical judgment as a\nso-called Gentzen sequent Note that this is a single judgment that should not be confused with\nthe derivation of the judgment \\({\\vdash}B\\) from the judgments\n\\({\\vdash}A_1, \\ldots, {\\vdash}A_n\\). When \\(n=0\\), then\nthe categorical judgment \\( {\\vdash}B\\) states that \\(B\\) is\ntrue without any assumptions. With sequent notation the familiar rule\nfor conjunctive introduction becomes Martin-Löf type theory has four basic forms of judgments and is a\nconsiderably more complicated system than first-order logic. One\nreason is that more information is carried around in the derivations\ndue to the identification of propositions and types. Another reason is\nthat the syntax is more involved. For instance, the well-formed\nformulas (types) have to be generated simultaneously with the provably\ntrue formulas (inhabited types). The four forms of categorical judgment are \\(\\vdash A \\; {\\rm type}\\), meaning that \\(A\\) is a well-formed\ntype, \\(\\vdash a {:} A\\), meaning that \\(a\\) has type \\(A\\), \\(\\vdash A = A'\\), meaning that \\(A\\) and \\(A'\\) are equal\ntypes, \\(\\vdash a = a' {:} A\\), meaning that \\(a\\) and \\(a'\\) are\nequal elements of type \\(A\\). In general, a judgment is hypothetical, that is, it is\nmade in a context \\(\\Gamma\\), that is, a list \\(x_1 {:} A_1, \\ldots, x_n\n{:} A_n\\) of variables which may occur free in the judgment together\nwith their respective types. Note that the types in a context can\ndepend on variables of earlier types. For example, \\(A_n\\) can depend\non \\(x_1 {:} A_1, \\ldots, x_{n-1} {:} A_{n-1}\\). The four forms of\nhypothetical judgments are \\(\\Gamma \\vdash A \\; {\\rm type}\\), meaning that \\(A\\) is a\nwell-formed type in the context \\(\\Gamma\\), \\(\\Gamma \\vdash a {:} A\\), meaning that \\(a\\) has type \\(A\\) in\ncontext \\(\\Gamma\\), \\(\\Gamma \\vdash A = A'\\), meaning that \\(A\\) and \\(A'\\) are\nequal types in the context \\(\\Gamma\\), \\(\\Gamma \\vdash a = a' {:} A\\), meaning that \\(a\\) and \\(a'\\)\nare equal elements of type \\(A\\) in the context \\(\\Gamma\\). Under the proposition as types interpretation \ncan be understood as the judgment that \\(a\\) is a proof-object for the\nproposition \\(A\\). When suppressing this object we get a judgment\ncorresponding to the one in ordinary first-order logic (see\nabove): Remark 3.1. Martin-Löf\n(1994) argues that\nKant’s analytic judgment a priori and synthetic judgment\na priori can be exemplified, in the realm of logic, by\n([analytic]) and ([synthetic]) respectively. In the analytic judgment\n([analytic]) everything that is needed to make the judgment evident is\nexplicit. For its synthetic version ([synthetic]) a possibly\ncomplicated proof construction \\(a\\) needs to be provided to make it\nevident. This understanding of analyticity and syntheticity has the\nsurprising consequence that “the logical laws in their usual\nformulation are all synthetic.” Martin-Löf (1994:\n95). His analysis further\ngives:  “ […] the logic of analytic judgments,\nthat is, the logic for deriving judgments of the two analytic forms,\nis complete and decidable, whereas the logic of synthetic judgments is\nincomplete and undecidable, as was shown by Gödel.”\nMartin-Löf (1994: 97).\n  The decidability of the two analytic judgments (\\(\\vdash a{:}A\\) and\n\\(\\vdash a=b{:}A\\)) hinges on the metamathematical properties of type\ntheory: strong normalization and decidable type checking.  Sometimes also the following forms are explicitly considered to be\njudgments of the theory: \\(\\Gamma \\; {\\rm context}\\), meaning that \\(\\Gamma\\) is a\nwell-formed context. \\(\\Gamma = \\Gamma'\\), meaning that \\(\\Gamma\\) and\n\\(\\Gamma'\\) are equal contexts. Below we shall abbreviate the judgment \\(\\Gamma \\vdash A \\; {\\rm\ntype}\\) as \\(\\Gamma \\vdash A\\) and \\(\\Gamma \\; {\\rm context}\\) as\n\\(\\Gamma \\vdash.\\) When stating the rules we will use the letter \\(\\Gamma\\) as a\nmeta-variable ranging over contexts, \\(A,B,\\ldots\\) as meta-variables\nranging over types, and \\(a,b,c,d,e,f,\\ldots\\) as meta-variables\nranging over terms. The first group of inference rules are general rules including\nrules of assumption, substitution, and context formation. There are\nalso rules which express that equalities are equivalence\nrelations. There are numerous such rules, and we only show the\nparticularly important rule of type equality which is crucial\nfor computation in types: The remaining rules are specific to the type formers. These are\nclassified as formation, introduction, elimination, and equality\nrules. We only give the rules for \\(\\Pi\\). There are analogous rules for\nthe other type formers corresponding to the logical constants of typed\npredicate logic. In the following \\(B[x := a]\\) means the term obtained by\nsubstituting the term \\(a\\) for each free occurrence of the variable\n\\(x\\) in \\(B\\) (avoiding variable capture). Furthermore, there are congruence rules expressing that operations\nintroduced by the formation, introduction, and elimination rules\npreserve equality. For example, the congruence rule for \\(\\Pi\\) is As in Peano arithmetic the natural numbers are generated by 0 and\nthe successor operation \\(\\s\\). The elimination rule states that these\nare the only possible ways to generate a natural number. We write \\(f(c) = \\R(c,d,xy.e)\\) for the function which is defined\nby primitive recursion on the natural number \\(c\\) with base case\n\\(d\\) and step function \\(xy.e\\) (or alternatively \\(\\lambda xy.e\\))\nwhich maps the value \\(y\\) for the previous number \\(x {:} \\N\\) to the\nvalue for \\(\\s(x)\\). Note that \\(\\R\\) is a new variable-binding\noperator: the variables \\(x\\) and \\(y\\) become bound in \\(e\\). The rule of \\(\\N\\)-elimination simultaneously expresses the type of\na function defined by primitive recursion and, under the Curry-Howard\ninterpretation, the rule of mathematical induction: we prove the\nproperty \\(C\\) of a natural number \\(x\\) by induction on \\(x\\). Gödel’s System \\(\\T\\) is essentially intuitionistic type theory with\nonly the type formers \\(\\N\\) and \\(A \\rightarrow B\\) (the type of\nfunctions from \\(A\\) to \\(B\\), which is the special case of \n\\((\\Pi x {:} A)B\\) where \\(B\\) does not depend on \\(x {:} A\\)). Since there are no\ndependent types in System \\(\\T\\) the rules can be simplified. Martin-Löf’s first version of type theory (Martin-Löf 1971a) had an\naxiom stating that there is a type of all types. This was proved\ninconsistent by Girard who found that the Burali-Forti paradox could\nbe encoded in this theory. To overcome this pathological impredicativity, but still retain\nsome of its expressivity, Martin-Löf introduced in 1972 a universe\n\\(\\U\\) of small types closed under all type formers of the theory,\nexcept that it does not contain itself (Martin-Löf 1998 [1972]). The rules\nare: Since \\(\\U\\) is a type, we can use \\(\\N\\)-elimination to define small\ntypes by primitive recursion. For example, if \\(A : \\U\\), we can define\nthe type of \\(n\\)-tuples of elements in \\(A\\) as follows: This type-theoretic universe \\(\\U\\) is analogous to a Grothendieck\nuniverse in set theory which is a set of sets closed under all the\nways sets can be constructed in Zermelo-Fraenkel set theory. The\nexistence of a Grothendieck universe cannot be proved from the usual\naxioms of Zermelo-Fraenkel set theory but needs a new axiom. In Martin-Löf (1975) the universe is extended to a countable\nhierarchy of universes In this way each type has a type, not only each small type. Above, we introduced the equality judgment \nThis is usually called a “definitional equality” because\nit can be decided by normalizing the terms \\(a\\) and \\(a'\\) and\nchecking whether the normal forms are identical. However, this\nequality is a judgment and not a proposition (type) and we thus cannot\nprove such judgmental equalities by induction. For this reason we need\nto introduce propositional identity types. For example, the identity\ntype for natural numbers \\(\\I(\\N,m,n)\\) can be defined by\n\\(\\U\\)-valued primitive recursion. We can then express and prove the\nPeano axioms. Moreover, extensional equality of ufnctions can be\ndefined by The following form of the axiom of choice is an immediate\nconsequence of the BHK-interpretation of the intuitionistic\nquantifiers, and is easily proved in intuitionistic type theory: The reason is that \\(\\Pi x {:} A. \\Sigma y {:} B. C\\) is the type of\nfunctions which map elements \\(x {:} A\\) to pairs \\((y,z)\\) with \\(y {:}\nB\\) and \\(z {:} C\\). The choice function \\(f\\) is obtained by returning\nthe first component \\(y {:} B\\) of this pair. It is perhaps surprising that intuitionistic type theory directly\nvalidates an axiom of choice, since this axiom is often considered\nproblematic from a constructive point of view. A possible explanation\nfor this state of affairs is that the above is an axiom of choice\nfor types, and that types are not in general appropriate\nconstructive approximations of sets in the classical sense. For\nexample, we can represent a real number as a Cauchy sequence in\nintuitionistic type theory, but the set of real numbers is not the\ntype of Cauchy sequences, but the type of Cauchy sequences up to\nequiconvergence. More generally, a set in Bishop’s constructive\nmathematics is represented by a type (commonly called\n“preset”) together with an equivalence relation. If \\(A\\) and \\(B\\) are equipped with equivalence relations, there\nis of course no guarantee that the choice function, \\(f\\) above, is\nextensional in the sense that it maps equivalent element to equivalent\nelements. This is the failure of the extensional axiom of\nchoice, see Martin-Löf (2009) for an analysis. The above completes the description of a core version of\nintuitionistic type theory close to that of (Martin-Löf 1998 [1972]). In 1986 Martin-Löf proposed a reformulation of intuitionistic type\ntheory; see Nordström, Peterson and Smith (1990) for an\nexposition. The purpose was to give a more compact formulation, where\n\\(\\lambda\\) and \\(\\Pi\\) are the only variable binding operations. It\nis nowadays considered the main version of the theory. It is also the\nbasis for the Agda proof assistant. The 1986 theory has two parts: the theory of types (the logical framework); the theory of sets (small types). Remark 4.1. Note that the word\n“set” in the logical framework does not coincide with the\nway it is used in Bishop’s constructive mathematics. To avoid this\nconfusion, types together with equivalence relations are usually\ncalled “setoids” or “extensional sets” in\nintuitionistic type theory. The logical framework has only two type formers: \\(\\Pi x {:} A. B\\)\n(usually written \\((x {:} A)B\\) or \\((x {:} A) \\rightarrow B\\) in the\nlogical framework formulation) and \\(\\U\\) (usually called\n\\(\\Set\\)). The rules for \\(\\Pi x{:} A. B\\) (\\((x {:} A) \\rightarrow B\\))\nare the same as given above (including \\(\\eta\\)-conversion). The rules\nfor \\(\\U\\) (\\(\\Set\\)) are also the same, except that the logical\nframework only stipulates closure under \\(\\Pi\\)-type formation. The other small type formers (“set formers”) are\nintroduced in the theory of sets. In the logical framework formulation\neach formation, introduction, and elimination rule can be expressed as\nthe typing of a new constant. For example, the rules for natural\nnumbers become \nwhere we have omitted the common context \\(\\Gamma\\), since the types\nof these constants are closed. Note that the recursion operator \\(R\\)\nhas a first argument \\(C {:} \\N \\rightarrow \\Set\\) unlike in the\noriginal formulation. Moreover, the equality rules can be expressed as equations under suitable assumptions. In the sequel we will present several extensions of type theory. To\nkeep the presentation uniform we will however not use the\nlogical framework presentation of type theory, but will use the same\nnotation as in section 2. As we mentioned above, identity on natural numbers can be defined\nby primitive recursion. Identity relations on other types can also be\ndefined in the basic version of intuitionistic type theory presented\nin section 2. However, Martin-Löf (1975) extended intuitionistic type theory with\na uniform primitive identity type former \\(\\I\\) for all types. The\nrules for \\(\\I\\) express that the identity relation is inductively\ngenerated by the proof of reflexivity, a canonicial constant called\n\\(\\r\\). (Note that \\(\\r\\) was coded by the number 0 in the introductory\npresentation of proof-objects\nin 2.3. The elimination rule for the identity type is a\ngeneralization of identity elimination in predicate logic and\nintroduces an elimination constant \\(\\J\\). We here show the\nformulation due to Paulin-Mohring (1993) rather than the\noriginal formulation of Martin-Löf (1975). The inference rules are\nthe following. \\(\\I\\)-formation.\n\n\\[\\frac{\\Gamma \\vdash A\n\\hspace{1em}\n\\Gamma \\vdash a {:} A\n\\hspace{1em}\n\\Gamma \\vdash a' {:} A}\n{\\Gamma \\vdash \\I(A,a,a')}\\] \\(\\I\\)-introduction.\n\n\\[\\frac{\\Gamma \\vdash A\n\\hspace{1em}\n\\Gamma \\vdash a {:} A}\n{\\Gamma \\vdash \\r {:} \\I(A,a,a)}\\] \\(\\I\\)-elimination. \\(\\I\\)-equality (under appropriate assumptions). Note that if \\(C\\) only depends on \\(x : A\\) and not on the proof \\(y : \\I(A,a,x)\\) (and we also suppress proof objects) in the rule of \\(\\I\\)-elimination we recover the rule of identity elimination in predicate logic. By constructing a model of type theory where types are interpreted\nas groupoids (categories where all arrows are isomorphisms)\nHofmann and Streicher (1998) showed that it cannot be proved in\nintuitionistic type theory that all proofs of \\(I(A,a,b)\\) are\nidentical. This may seem as an incompleteness of the theory and\nStreicher suggested a new axiom \\(\\K\\) from which it follows that all\nproofs of \\(\\I(A,a,b)\\) are identical to \\(\\r\\). The \\(\\I\\)-type is often called the intensional identity\ntype, since it does not satisfy the principle of function\nextensionality. Intuitionistic type theory with the intensional\nidentity type is also often called intensional intuitionistic type\ntheory to distinguish it from extensional intuitionistic type\ntheory which will be presented in\n section 7.1. A type of well-founded trees of the form \\(\\W x {:} A. B\\) was\nintroduced in Martin-Löf 1982 (and in a more restricted form by Scott\n1970). Elements of \\(\\W x {:} A. B\\) are trees of varying and arbitrary\nbranching: varying, because the branching type \\(B\\) is indexed by \\(x\n{:} A\\) and arbitrary because \\(B\\) can be arbitrary. The type is given\nby a generalized inductive definition since the well-founded\ntrees may be infinitely branching. We can think of \\(\\W x{:}A. B\\) as the\nfree term algebra, where each \\(a {:} A\\) represents a term constructor\n\\(\\sup\\,a\\) with (possibly infinite) arity \\(B[x := a]\\). We omit the rules of \\(\\W\\)-elimination and \\(\\W\\)-equality. Adding well-founded trees to intuitionistic type theory increases\nits proof-theoretic strength significantly (Setzer\n(1998)). An important application of well-founded trees is Aczel’s (1978)\nconstruction of a type-theoretic model of Constructive Zermelo\nFraenkel Set Theory. To this end he defines the type of iterative sets\nas Let \\(A {:} \\U\\) be a small type, and \\(x {:} A\\vdash M\\) be an indexed\nfamily of iterative sets. Then \\(\\sup(A,x.M)\\), or with a more\nsuggestive notation \\(\\{ M\\mid x {:} A\\}\\), is an iterative set. To\nparaphrase: an iterative set is a family of iterative sets indexed by a small type. Note that an iterative set is a data-structure in the sense of\nfunctional programming: a possibly infinitely branching well-founded\ntree. Different trees may represent the same set. We therefore need to\ndefine a notion of extensional equality between iterative sets which\ndisregards repetition and order of elements. This definition is\nformally similar to the definition of bisimulation of processes in\nprocess algebra. The type \\(\\V\\) up to extensional equality can be\nviewed as a constructive type-theoretic model of the cumulative\nhierarchy, see the entry on \n  set theory: constructive and intuitionistic ZF\nfor further information about CZF. The notion of an inductive definition is fundamental in\nintuitionistic type theory. It is a primitive notion and not, as in\nset theory, a derived notion where an inductively defined set is\ndefined impredicatively as the smallest set closed under some\nrules. However, in intuitionistic type theory inductive definitions\nare considered predicative: they are viewed as being built up from\nbelow. The inductive definability of types is inherent in the meaning\nexplanations of intuitionistic type theory which we shall discuss in\nthe next section. In fact, intuitionistic type theory can be described\nbriefly as a theory of inductive, recursive, and inductive-recursive\ndefinitions based on a framework of lambda calculus with dependent\ntypes. We have already seen the type of natural numbers and the type of\nwell-founded trees as examples of types given by inductive\ndefinitions; the natural numbers is an example of an ordinary finitary\ninductive definition and the well-founded trees of a generalized\npossibly infinitary inductive definition. The introduction rules\ndescribe how elements of these types are inductively generated and the\nelimination and equality rules describe how functions from these types\ncan be defined by structural recursion on the way these elements are\ngenerated. According to the propositions as types principle, the\nelimination rules are simultaneously rules for proof by structural\ninduction on the way the elements are generated. The type formers \\(0, 1, +, \\times, \\rightarrow, \\Sigma,\\) and\n\\(\\Pi\\) which interpret the logical constants for intuitionistic\npredicate logic are examples of degenerate inductive definitions. Even\nthe identity type (in intensional intuitionistic type theory) is\ninductively generated; it is the type of proofs generated by the\nreflexivity axiom. Its elimination rule expresses proof by pattern\nmatching on the proof of reflexivity. The common structure of the rules of the type formers can be\ncaptured by a general schema for inductive definitions (Dybjer\n1991). This general schema has many useful instances, for example, the\ntype \\(\\List(A)\\) of lists with elements of type \\(A\\) has the\nfollowing introduction rules: Other useful instances are types of binary trees and other trees\nsuch as the infinitely branching trees of the Brouwer ordinals of the\nsecond and higher number classes. The general schema does not only cover inductively defined types,\nbut also inductively defined families of types, such as the identity\nrelation. The above mentioned type \\(A^n\\) of \\(n\\)-tuples of type\n\\(A\\) was defined above by primitive recursion on \\(n\\). It can also\nbe defined as an inductive family with the following introduction\nrules The schema for inductive types and families is a type-theoretic\ngeneralization of a schema for iterated inductive definitions in\npredicate logic (formulated in natural deduction) presented by\nMartin-Löf (1971b). This paper immediately preceded\nMartin-Löf’s first version of intuitionistic type\ntheory. It is both conceptually and technically a forerunner to the\ndevelopment of the theory. It is an essential feature of proof assistants such as Agda and Coq\nthat it enables users to define their own inductive types and families\nby listing their introduction rules (the types of their\nconstructors). This is much like in typed functional programming\nlanguages such as Haskell and the different dialects of ML. However,\nunlike in these programming languages the schema for inductive\ndefinitions in intuitionistic type theory enforces a restriction\namounting to well-foundedness of the elements of the defined\ntypes. We already mentioned that there are two main definition principles\nin intuitionistic type theory: the inductive definition of types\n(sets) and the (primitive, structural) definition of functions by\nrecursion on the way the elements of such types are inductively\ngenerated. Usually, the inductive definition of a set comes first: the\nformation and introduction rules make no reference to the elimination\nrule. However, there are definitions in intuitionistic type theory for\nwhich this is not the case and we simultaneously inductively generate\na type and a function from that type defined by structural\nrecursion. Such definitions are\nsimultaneously inductive-recursive. The first example of such an inductive-recursive definition is an\nalternative formulation à la Tarski of the universe of small\ntypes. Above we presented the universe formulated à la\nRussell, where there is no notational distinction between the\nelement \\(A {:} \\U\\) and the corresponding type \\(A\\). For a\nuniverse à la Tarski there is such a distinction, for\nexample, between the element \\(\\hat{\\N} {:} \\U\\) and the corresponding\ntype \\(\\N\\). The element \\(\\hat{\\N}\\) is called the code for\n\\(\\N\\). The elimination rule for the universe à la Tarski is: This expresses that there is a function \\(\\T\\) which maps a code\n\\(a\\) to its corresponding type \\(T(a)\\). The equality rules define\nthis correspondence. For example, We see that \\(\\U\\) is inductively generated with one introduction\nrule for each small type former, and \\(\\T\\) is defined by recursion on\nthese small type formers. The simultaneous inductive-recursive nature\nof this definition becomes apparent in the rules for \\(\\Pi\\) for\nexample. The introduction rule is and the corresponding equality rule is \nNote that the introduction rule for \\(\\U\\) refers to \\(\\T\\), and hence\nthat \\(\\U\\) and \\(\\T\\) must be defined simultaneously. There are a number of other universe constructions which are\ndefined inductive-recursively: universe hierarchies, superuniverses\n(Palmgren 1998; Rathjen, Griffor, and Palmgren 1998), and Mahlo\nuniverses (Setzer 2000). These universes are analogues of certain\nlarge cardinals in set theory: inaccessible, hyperinaccessible, and\nMahlo cardinals. Other examples of inductive-recursive definitions include an\ninformal definition of computability predicates used by Martin-Löf in\nan early normalization proof of intuitionistic type theory (Martin-Löf\n1998 [1972]). There are also many natural examples of “small”\ninductive-recursive definitions, where the recursively defined\n(decoding) function returns an element of a type rather than a\ntype. A large class of inductive-recursive definitions, including the\nabove, can be captured by a general schema (Dybjer 2000) which extends\nthe schema for inductive definitions mentioned above. As shown by\nSetzer, intuitionistic type theory with this class of\ninductive-recursive definitions is very strong proof-theoretically\n(Dybjer and Setzer 2003). However, as proposed in recent unpublished\nwork by Setzer, it is possible to increase the strength of the theory\neven further and define universes such as an autonomous Mahlo\nuniverse which are analogues of even larger cardinals. The consistency of intuitionistic type theory relative to set\ntheory can be proved by model constructions. Perhaps the simplest\nmethod is an interpretation whereby each type-theoretic concept is\ngiven its corresponding set-theoretic meaning, as outlined\nin \n section 2.3. For example the type of functions \\(A \\rightarrow B\\)\nis interpreted as the set of all functions in the set-theoretic sense\nbetween the set denoted by \\(A\\) and the set denoted by \\(B\\). To\ninterpret \\(\\U\\) we need a set-theoretic universe which is closed under\nall (set-theoretic analogues of) the type constructors. Such a\nuniverse can be proved to exist if we assume the existence of an\ninaccessible cardinal \\(\\kappa\\) and interpret \\(\\U\\) by \\(V_\\kappa\\)\nin the cumulative hierarchy. Alternatives are realizability models, and for intensional type\ntheory, a model of terms in normal forms. The latter can also be used\nfor proving decidability of the judgments of the theory. Mathematical models only prove consistency relative to classical\nset theory (or whatever other meta-theory we are using). Is it\npossible to be convinced about the consistency of the theory in a more\ndirect way, so called simple minded consistency\n(Martin-Löf 1984)? In fact, is there a way to explain what\nit means for a judgment to be correct in a\ndirect pre-mathematical way? And given that we know what the\njudgments mean can we then be convinced that the inference rules of\nthe theory are valid? An answer to this problem was proposed by\nMartin-Löf in 1979 in the paper “Constructive Mathematics\nand Computer Programming” (Martin-Löf 1982) and elaborated\nlater on in numerous lectures and notes, see for example,\nMartin-Löf (1984, 1987). These meaning explanations for\nintuitionistic type theory are also referred to as the direct\nsemantics, intuitive semantics, informal\nsemantics, standard semantics, or\nthe syntactico-semantical approach to meaning theory. This meaning theory follows the Wittgensteinian meaning-as-use\ntradition. The meaning is based on rules for building objects\n(introduction rules) of types and computation rules (elimination\nrules) for computing with these objects. A difference from much of the\nWittgensteinian tradition is that also higher order types like \\(\\N\n\\rightarrow \\N\\) are given meaning using rules. To explain the meaning of a judgment we must first know how the\nterms in the judgment are computed to canonical form. Then the\nformation rules explain how correct canonical types are built and the\nintroduction rules explain how correct canonical objects of such\ncanonical types are built. We quote (Martin-Löf 1982):  \nIn other words, a canonical type is equipped with an equivalence\nrelation on the canonical objects. Below we shall give a simplified\nform of the meaning explanations, where this equivalence relation is\nextensional identity of objects. In spite of the pre-mathematical nature of this meaning\ntheory, its technical aspects can be captured as a mathematical model\nconstruction similar to Kleene’s realizability interpretation\nof intuitionistic logic, see the next section. The realizers here are\nthe terms of type theory rather than the number realizers used by\nKleene. The meaning of a judgment is explained in terms of the computation\nof the types and terms in the judgment. These computations stop when a\ncanonical form is reached. By canonical form we mean a term where the outermost form is a constructor (introduction form). These are the canonical forms used in lazy\nfunctional programming (for example in the Haskell language). For the purpose of illustration we consider meaning explanations\nonly for three type formers: \\(\\N, \\Pi x {:} A.B\\), and \\(\\U\\). The\ncontext free grammar for the terms of this fragment of Intuitionistic\nType Theory is as follows: The canonical terms are generated by the following grammar: where \\(a\\) ranges over arbitrary, not necessarily canonical,\nterms. Note that \\(\\s(a)\\) is canonical even if \\(a\\) is not. To explain how terms are computed to canonical form, we introduce the relation \\(a \\Rightarrow\nv\\) between closed terms \\(a\\) and canonical forms (values)\n\\(v\\) given by the following computation rules: in addition to the rule stating that a canonical term has itself as value. A categorical judgment is a judgment where the context is empty and\nthere are no free variables. The meaning of the categorical judgment \\(\\vdash A\\) is that \\(A\\)\nhas a canonical type as value. In our fragment this means that either\nof the following holds: \\(A \\Rightarrow \\N\\), \\(A \\Rightarrow \\U\\), \\(A \\Rightarrow \\Pi x {:} B. C\\) and furthermore that \\(\\vdash B\\) and\n\\(x {:} B \\vdash C\\). The meaning of the categorical judgment \\(\\vdash a {:} A\\) is that\n\\(a\\) has a canonical term of the canonical type of \\(A\\) as value. In\nour fragment this means that either of the following holds: \\(A \\Rightarrow \\N\\) and either \\(a \\Rightarrow 0\\) or \\(a\n    \\Rightarrow \\s(b)\\) and \\(\\vdash b {:} \\N\\), \\(A \\Rightarrow \\U\\) and either \\(a \\Rightarrow \\N\\) or \\(a\n    \\Rightarrow \\Pi x {:} b. c\\) where furthermore \\(\\vdash b {:} \\U\\) and\n    \\(x {:} b \\vdash c {:} \\U\\), \\(A \\Rightarrow \\Pi x {:} B. C\\) and \\(a \\Rightarrow \\lambda x.c\\) and\n\\(x {:} B \\vdash c {:} C\\). The meaning of the categorical judgment \\(\\vdash A = A'\\) is\nthat \\(A\\) and \\(A'\\) have the same canonical types as values. In\nour fragment this means that either of the following holds: \\(A \\Rightarrow \\N\\) and \\(A' \\Rightarrow \\N\\), \\(A \\Rightarrow \\U\\) and \\(A' \\Rightarrow \\U\\), \\(A \\Rightarrow \\Pi x {:} B. C\\) and \\(A' \\Rightarrow \\Pi x {:}\nB'. C'\\) and furthermore that \\(\\vdash B = B'\\) and \\(x {:} B\n\\vdash C = C'\\). The meaning of the categorical judgment \\(\\vdash a = a' {:} A\\)\nis explained in a similar way. It is a tacit assumption of the meaning explanations that the\nrepeated computations of canonical forms is well-founded. For example,\na natural number is the result of finitely many computations of the\nsuccessor function \\(\\s\\) ended by \\(0\\). A computation which results\nin infinitely many computations of \\(\\s\\) is not a natural number in\nintuitionistic type theory. (However, there are extensions of type\ntheory, for example, partial type theory, and non-standard type\ntheory, where such infinite computations can occur,\nsee section 7.3. To justify the rules of such\ntheories the present meaning explanations do not suffice.) According to Martin-Löf (1982) the meaning of a hypothetical\njudgment is reduced to the meaning of the categorical judgments by\nsubstituting the closed terms of appropriate types for the free\nvariables. For example, the meaning of is that the categorical judgment is valid whenever the categorical judgments are valid. Curry’s correspondence between propositions and types was extended\nto predicate logic in the late 1960s by Howard (1980) and de Bruijn\n(1970). At around the same time Lawvere developed related ideas in\ncategorical logic. In particular he proposed the notion of\na hyperdoctrine (Lawvere 1970) as a categorical model of\n(typed) predicate logic. A hyperdoctrine is an indexed category \\(P {:}\nT^{op} \\rightarrow \\mathbf{Cat}\\), where \\(T\\) is a category where the\nobjects represent types and the arrows represent terms. If \\(A\\) is a\ntype then the fibre \\(P(A)\\) is a category of propositions\ndepending on a variable \\(x {:} A\\). The arrows in this category are\nproofs \\(Q \\vdash R\\) and can be thought of as\nproof-objects. Moreover, since we have an indexed category, for each\narrow \\(t\\) from \\(A\\) to \\(B\\), there is a reindexing functor \\(P(B)\n\\rightarrow P(A)\\) representing substitution of \\(t\\) for a variable\n\\(y {:} B\\). The category \\(P(A)\\) is assumed to be cartesian closed and\nconjunction and implications are modelled by products and exponentials\nin this category. The quantifiers \\(\\exists\\) and \\(\\forall\\) are\nmodelled by the left and right adjoints of the reindexing\nfunctor. Moreover, Lawvere added further structure to hyperdoctrines\nto model identity propositions (as left adjoints to a diagonal\nfunctor) and a comprehension schema. Lawvere’s definition of hyperdoctrines preceded intuitionistic type\ntheory but did not go all the way to identifying propositions and types. Nevertheless Lawvere influenced\nScott’s (1970) work on constructive validity, a somewhat\npreliminary precursor of intuitionistic type theory. After Martin-Löf\n(1998 [1972]) had presented a\nmore definite formulation of the theory, the first work on categorical\nmodels was presented by Cartmell in 1978 with his notions of category\nwith attributes and contextual category (Cartmell 1986). However, we\nwill not define these structures here but instead the closely\nrelated categories with families (Dybjer 1996) which are\nformulated so that they directly model a variable-free version of a\nformulation of intuitionistic type theory with explicit substitutions\n(Martin-Löf 1995). A category with families is a functor \\(T {:} C^{op} \\rightarrow\n\\mathbf{Fam}\\), where \\(\\mathbf{Fam}\\) is the category of families of\nsets. The category \\(C\\) is the category of contexts and\nsubstitutions. If \\(\\Gamma\\) is an object of \\(C\\) (a context), then\n\\(T(\\Gamma)\\) is the family of terms of type \\(A\\) which depend on\nvariables in \\(\\Gamma\\). If \\(\\gamma\\) is an arrow in \\(C\\)\nrepresenting a substitution, then the arrow part of the functor\nrepresents substitution of \\(\\gamma\\) in types and terms. A category\nwith families also has a terminal object and a notion of context\ncomprehension, reminiscent of Lawvere’s comprehension in\nhyperdoctrines. The terminal object captures the rules for empty\ncontexts and empty substitutions. Context comprehension captures the\nrules for extending contexts and substitutions, and has projections\ncapturing weakening and assumption of the last variable. Categories with families are algebraic structures which model the\ngeneral rules of dependent type theory, those which come before the\nrules for specific type formers, such as \\(\\Pi\\), \\(\\Sigma\\), identity\ntypes, universes, etc. In order to model specific type-former\ncorresponding extra structure needs to be added. From a categorical perspective the above-mentioned structures may\nappear somewhat special and ad hoc. A more regular structure which\ngives rise to models of intuitionistic type theory are the locally\ncartesian closed categories. These are categories with a terminal\nobject, where each slice category is cartesian closed. It can be shown\nthat the pullback functor has a left and a right adjoint, representing\n\\(\\Sigma\\)- and \\(\\Pi\\)-types, respectively. Locally cartesian closed\ncategories correspond to intuitionistic type theory with extensional\nidentity types and \\(\\Sigma\\) and \\(\\Pi\\)-types (Seely 1984,\nClairambault and Dybjer 2014). It should be remarked that the\ncorrespondence with intuitionistic type theory is somewhat indirect,\nsince a coherence problem, in the sense of category theory, needs to\nbe solved. The problem is that in locally cartesian closed categories\ntype substituion is represented by pullbacks, but these are only\ndefined up to isomorphism, see Curien 1993 and Hofmann 1994. Intuitionistic type theory is a possible framework for constructive\nmathematics in Bishop’s sense. Such constructive mathematics is\ncompatible with classical mathematics: a constructive proof in\nBishop’s sense can directly be understood as a proof in classical\nlogic. A formal way to understand this is by constructing a\nset-theoretic model of intuitionistic type theory, where each concept\nof type theory is interpreted as the corresponding concept in\nZermelo-Fraenkel Set Theory. For example, a type is interpreted as a\nset, and the type of functions in \\(A \\rightarrow B\\) is interpreted\nas the set of all functions in the set-theoretic sense from the set\nrepresenting \\(A\\) to the set representing \\(B\\). The type of natural\nnumbers is interpreted as the set of natural numbers. The\ninterpretations of identity types, and \\(\\Sigma\\) and \\(\\Pi\\)-types\nwere already discussed in the introduction. And as already mentioned,\nto interpret the type-theoretic universe we need an inaccessible\ncardinal. It can be shown that the interpretation outlined above can be\ncarried out in Aczel’s constructive set theory CZF. Hence it does not\ndepend on classical logic or impredicative features of set theory. The set-theoretic model can be criticized on the grounds that it\nmodels the type of functions as the set of all set-theoretic\nfunctions, in spite of the fact that a function in type theory is\nalways computable, whereas a set-theoretic function may not be. To remedy this problem one can instead construct\na realizability model whereby one starts with a set\nof realizers. One can here follow Kleene’s numerical\nrealizability closely where functions are realized by codes for Turing\nmachines. Or alternatively, one can let realizers be terms in a lambda\ncalculus or combinatory logic possibly extended with appropriate\nconstants. Types are then represented by sets of realizers, or often\nas partial equivalence relations on the set of realizers. A partial\nequivalence relation is a convenient way to represent a type with a\nnotion of “equality” on it. There are many variations on the theme of realizability model. Some\nsuch models tacitly\nassume set theory as the metatheory (Aczel 1980, Beeson 1985), whereas others explictly assume a\nconstructive metatheory (Smith 1984). Realizability models are also models of the extensional version of\nintuitionistic type theory (Martin-Löf 1982) which will be presented\nin section 7.1 below. In intuitionistic type theory each type and each well-typed term\nhas a normal form. A consequence of this normal form property is that\nall the judgments are decidable: for example, given a correct context\n\\(\\Gamma\\), a correct type \\(A\\) and a possibly ill-typed term \\(a\\),\nthere is an algorithm for deciding whether \\(\\Gamma \\vdash a {:}\nA\\). This type-checking algorithm is the key component of\nproof-assistants for Intensional Type Theory, such as Agda. The correctness of the normal form property can be expressed as a\nmodel of normal forms, where each context, type, and term are\ninterpreted as their respective normal forms. In extensional intuitionistic type theory (Martin-Löf 1982) the\nrules of \\(\\I\\)-elimination and \\(\\I\\)-equality for the general identity\ntype are replaced by the following two rules: \nThe first causes the distinction between\npropositional and judgmental equality to disappear. The second forces\nidentity proofs to be unique. Unlike the rules for the intensional\nidentity type former, the rules for extensional identity types do not\nfit into the schema for inductively defined types mentioned above. These rules are however justified by the meaning explanations in\nMartin-Löf (1982). This is because the categorical judgment is valid iff \\(c \\Rightarrow \\r\\) and the judgment \\(\\vdash a = a' {:}\nA\\) is valid. However, these rules make it possible to define terms without\nnormal forms. Since the type-checking algorithm relies on the\ncomputation of normal forms of types, it no longer works for\nextensional type theory, see (Castellan, Clairambault, and Dybjer 2015). On the other hand, certain constructions which are not available in\nintensional type theory are possible in extensional type theory. For\nexample, function extensionality is a theorem. Another example is that \\(\\W\\)-types can be used for encoding other\ninductively defined types in Extensional Type Theory. For example, the\nBrouwer ordinals of the second and higher number classes can be\ndefined as special instances of the \\(\\W\\)-type (Martin-Löf 1984). More\ngenerally, it can be shown that all inductively defined types which\nare given by a strictly positive type operator can be\nrepresented as instances of well-founded trees (Dybjer 1997). Univalent foundations refer to Voevodsky’s programme for a new\nfoundation of mathematics based on intuitionistic type theory and\nemploying ideas from homotopy theory. Here every type \\(A\\) is\nconsidered as a space, and the identity type \\(\\I(A,a,b)\\) is the space\nof paths from point \\(a\\) to point \\(b\\) in \\(A\\). Iterated identity types represent higher homotopies, e.g. is the space of homotopies between \\(f\\) and \\(g\\).\nThe notion of\nordinary set can be thought of as a discrete space \\(A\\) where\nall paths in \\(\\I(A,a,b)\\) are trivial loops. \n\nThe origin of these ideas\nwas the remarkable discovery by (Hofmann and Streicher 1998) that the axioms of\nintensional type theory do not force all proofs of an identity to be equal, that is, not all paths need to be trivial. This was\nshown by a model construction where each type is interpreted as a\ngroupoid.  \nFurther connections between identity\ntypes and notions from homotopy theory and higher categories were\nsubsequently discovered by (Awodey and Warren 2009), (Lumsdaine 2010), and\n(van den Berg and Garner 2011). Voevodsky realized that the whole intensional intuitionistic type\ntheory could be modelled by a well-known category studied in homotopy\ntheory, namely the Kan simplicial sets. Inspired by this model he\nintroduced the univalence axiom. For a universe\n\\(\\U\\) of small types, this axiom states that the substitution map associated with\nthe \\(J\\)-operator \nis an equivalence. Equivalence (\\(\\cong\\)) here refers to a general notion of\nequivalence of higher dimensional objects, as in the\nsequence equal elements, isomorphic sets, equivalent groupoids,\nbiequivalent bigroupoids, etc. The univalence axiom expresses\nthat “everything is preserved by equivalence”, thereby\nrealizing the informal categorical slogan that all categorical\nconstructions are preserved by isomorphism, and its generalization,\nthat all constructions of categories are preserved by equivalence of\ncategories, etc. The axiom of univalence was originally justified by\nVoevodsky’s simplical set model. This model is however not\nconstructive and (Bezem, Coquand and Huber 2014 [2013]) has more\nrecently proposed a model in Kan cubical sets. Although univalent foundations concern preservation of mathematical\nstructure in general, strongly inspired by category theory,\napplications within homotopy theory are particularly actively\ninvestigated. Intensional type theory extended with the univalence\naxiom and so called higher inductive types is therefore also called\n“homotopy type theory”. We refer to the entry on\n type theory for further details. Intuitionistic type theory is not intended to model Brouwer’s\nnotion of free choice sequence, although lawlike choice\nsequences can be modelled as functions from \\(\\N\\). However, there are\nextensions of the theory which incorporate such choice sequences:\nnamely partial type theory and non-standard type\ntheory (Martin-Löf 1990). The types in partial type theory\ncan be interpreted as Scott domains (Martin-Löf 1986, Palmgren\nand Stoltenberg-Hansen 1990, Palmgren 1991). In this way a type \\(\\N\\)\nwhich contains an infinite number \\(\\infty\\) can be\ninterpreted. However, in partial type theory all types are inhabited\nby a least element \\(\\bot\\), and thus the propositions as types\nprinciple is not maintained. Non-standard type theory incorporates\nnon-standard elements, such as an infinite number \\(\\infty {:} \\N\\)\nwithout inhabiting all types. The inconsistent version of intuitionistic type theory of\nMartin-Löf (1971a) was based on the strongly impredicative axiom that\nthere is a type of all types. However, (Coquand and Huet 1988) showed with their\ncalculus of constructions, that there is a powerful impredicative but\nconsistent version of type theory. In this theory the universe \\(\\U\\)\n(usually called \\({\\bf Prop}\\) in this theory) is closed under the following formation rule\nfor cartesian product of families of types: This rule is more general than the rule for constructing small\ncartesian products of families of small types in intuitionistic type\ntheory, since we can now quantify over arbitrary types \\(A\\),\nincluding \\(\\U\\), and not just small types. We say that \\(\\U\\) is impredicative since we can construct a new element of it by quantifying over all elements, even the element which is constructed. The motivation for this theory was that inductively defined types\nand families of types become definable in terms of impredicative\nquantification. For example, the type of natural numbers can be\ndefined as the type of Church numerals: This is an impredicative definition, since it is a small type which\nis constructed by quantification over all small types. Similarly we\ncan define an identity type by impredicative quantification: This is Leibniz’ definition of equality: \\(a\\) and \\(a'\\) are\nequal iff they satisfy the same properties (ranged over by \\(X\\)). Unlike in intuitionistic type theory, the function type in\nimpredicative type cannot be interpreted set-theoretically in a\nstraightfoward way, see (Reynolds 1984). In 1979 Martin-Löf wrote the paper “Constructive Mathematics\nand Computer Programming” where he explained that intuitionistic\ntype theory is a programming language which can also be used as a\nformal foundation for constructive mathematics. Shortly after that,\ninteractive proof systems which help the user to derive valid\njudgments in the theory, so called proof assistants, were\ndeveloped. One of the first systems was the NuPrl system (PRL Group 1986),\nwhich is based on an extensional type theory similar to (Martin-Löf\n1982). Systems based on versions of intensional type theory go back to the\ntype-checker for the impredicative calculus of constructions which was\nwritten around 1984 by Coquand and Huet. This led to the Coq system,\nwhich is based on the calculus of inductive constructions\n(Paulin-Mohring 1993), a theory which extends the calculus of\nconstruction with primitive inductive types and families. The\nencodings of the pure calculus of constructions were found to be\ninconvenient, since the full elimination rules could not be derived\nand instead had to be postulated. We also remark that the calculus of\ninductive constructions has a subsystem, the predicative calculus of\ninductive constructions, which follows the principles of\nMartin-Löf’s intuitionistic type theory. Agda is another proof assistant which is based on the logical\nframework formulation of intuitionistic type theory, but adds numerous\nfeatures inspired by practical programming languages (Norell 2008). It\nis an intensional theory with decidable judgments and a type-checker\nsimilar to Coq’s. However, in contrast to Coq it is based on\nMartin-Löf’s predicative intuitionistic type theory. There are several other systems based either on the calculus of\nconstructions (Lego, Matita, Lean) or on intuitionistic type theory\n(Epigram, Idris); see (Pollack 1994; Asperti et al. 2011; de Moura et al. 2015;\nMcBride and McKinna 2004; Brady 2011).","contact.mail":"peterd@chalmers.se","contact.domain":"chalmers.se"}]
